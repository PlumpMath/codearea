// Generated by CoffeeScript 1.3.1
var textareaEditor,
  __slice = [].slice;

textareaEditor = function(target_id) {
  var at_line_end, at_line_sta, event_handler, g_id, get_column, get_row, indent_n, key_backspace, key_bracket, key_bracket_close, key_ctrl_enter, key_ctrl_k, key_ctrl_l, key_ctrl_shift_d, key_ctrl_shift_down, key_ctrl_shift_enter, key_ctrl_shift_k, key_ctrl_shift_up, key_ctrl_u, key_enter, key_equal, key_esc, key_shift_tab, key_tab, line_empty, map_keys, o, press, set_position, tool, wrap_text, write_text;
  g_id = function(tagid) {
    return document.getElementById(tagid);
  };
  o = function() {
    var v;
    v = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return console.log(v);
  };
  wrap_text = function(area) {
    var contx, end, lines, obj, start;
    start = area.selectionStart;
    end = area.selectionEnd;
    contx = area.value;
    lines = contx.split('\n');
    return obj = {
      lines: lines,
      a_row: get_row(contx, start),
      a_col: get_column(contx, start),
      a_sta: at_line_sta(contx, start),
      a_end: at_line_end(contx, start),
      b_row: get_row(contx, end),
      b_col: get_column(contx, end),
      b_sta: at_line_sta(contx, end),
      b_end: at_line_end(contx, end),
      same: start === end,
      tail: lines.length - 1
    };
  };
  write_text = function(area, obj) {
    var a_col, a_row, arr, b_col, b_row, end_line;
    arr = obj.lines.length > 0 ? obj.lines : [''];
    end_line = arr.length - 1;
    a_row = obj.a_row != null ? obj.a_row : end_line;
    a_col = obj.a_col != null ? obj.a_col : arr[a_row].length;
    b_row = obj.b_row != null ? obj.b_row : a_row;
    if (obj.b_col != null) {
      b_col = obj.b_col;
    } else {
      if (obj.b_row != null) {
        b_col = arr[b_row].length;
      } else {
        b_col = a_col;
      }
    }
    area.value = arr.join('\n');
    area.selectionStart = set_position(arr, a_row, a_col);
    return area.selectionEnd = set_position(arr, b_row, b_col);
  };
  set_position = function(arr, row, col) {
    var inline_before_curse, lines_before_curse, position, text_before_curse;
    lines_before_curse = arr.slice(0, row);
    inline_before_curse = arr[row] != null ? arr[row].slice(0, col) : '';
    lines_before_curse.push(inline_before_curse);
    text_before_curse = lines_before_curse.join('\n');
    return position = text_before_curse.length;
  };
  get_row = function(str, point) {
    var count, i, _i, _len;
    count = 0;
    str = str.slice(0, point);
    for (_i = 0, _len = str.length; _i < _len; _i++) {
      i = str[_i];
      if (i === '\n') {
        count += 1;
      }
    }
    return count;
  };
  get_column = function(str, point) {
    var last, n, sub_str;
    str = str.slice(0, point);
    last = str.lastIndexOf('\n');
    last += 1;
    sub_str = str.slice(last);
    return n = sub_str.length;
  };
  at_line_sta = function(text, point) {
    var p;
    p = point - 1;
    if (text[p] === '\n') {
      return true;
    }
    if (text[p] == null) {
      return true;
    }
    return false;
  };
  at_line_end = function(text, point) {
    var p;
    p = point;
    if (text[p] === '\n') {
      return true;
    }
    if (text[p] == null) {
      return true;
    }
    return false;
  };
  line_empty = function(line) {
    if ((line.match(/^\s*$/)) != null) {
      return true;
    } else {
      return false;
    }
  };
  indent_n = function(str) {
    var count;
    count = 0;
    while (str[0] != null) {
      if (str[0] === ' ') {
        count += 1;
      }
      str = str.slice(1);
    }
    return count;
  };
  tool = {
    wrap_text: wrap_text,
    write_text: write_text,
    line_empty: line_empty,
    indent_n: indent_n
  };
  event_handler = function(tagid) {
    var area;
    area = g_id(tagid);
    return area.onkeydown = function(e) {
      var alt, arr, code, ctrl, shift;
      code = e.keyCode || e.charCode;
      o(e.keyCode, e.charCode, '::', code);
      shift = e.shiftKey;
      alt = e.altKey;
      ctrl = e.ctrlKey;
      arr = [ctrl, alt, shift, code];
      return map_keys(arr, area, key_equal);
    };
  };
  key_equal = function(_arg, _arg1) {
    var a1, a2, a3, a4, b1, b2, b3, b4;
    a1 = _arg[0], a2 = _arg[1], a3 = _arg[2], a4 = _arg[3];
    b1 = _arg1[0], b2 = _arg1[1], b3 = _arg1[2], b4 = _arg1[3];
    if (a1 !== b1) {
      return false;
    }
    if (a2 !== b2) {
      return false;
    }
    if (a3 !== b3) {
      return false;
    }
    if (a4 !== b4) {
      return false;
    }
    return true;
  };
  key_tab = function(area) {
    var add_n, end_line, index, lines, now, obj, row, space_n, spaces, sta_line, _i;
    now = tool.wrap_text(area);
    if (now.same) {
      lines = now.lines;
      row = now.a_row;
      if (now.a_sta && row > 0 && lines[row - 1].match(/^\s+/)) {
        spaces = (lines[row - 1].match(/^\s+/))[0];
        space_n = spaces.length;
        lines[row] = spaces + lines[row];
        obj = {
          lines: lines,
          a_row: row,
          a_col: space_n
        };
        tool.write_text(area, obj);
      } else {
        spaces = (lines[row].match(/^\s*/))[0];
        space_n = spaces.length;
        add_n = 2 - space_n % 2;
        if (add_n === 1) {
          lines[row] = '\ ' + lines[row];
        } else {
          lines[row] = '\ \ ' + lines[row];
        }
        obj = {
          lines: lines,
          a_row: row,
          a_col: now.a_col + add_n
        };
        tool.write_text(area, obj);
      }
    } else {
      sta_line = now.a_row;
      end_line = now.b_row;
      lines = now.lines;
      for (index = _i = sta_line; sta_line <= end_line ? _i <= end_line : _i >= end_line; index = sta_line <= end_line ? ++_i : --_i) {
        lines[index] = '\ \ ' + lines[index];
      }
      obj = {
        lines: lines,
        a_row: sta_line,
        a_col: now.a_col,
        b_row: end_line,
        b_col: now.b_col + 2
      };
      tool.write_text(area, obj);
    }
    return false;
  };
  key_shift_tab = function(area) {
    var end_row, index, lines, min_spaces, now, obj, reduce_n, row, space_n, space_ns, spaces, sta_row, _i;
    now = tool.wrap_text(area);
    lines = now.lines;
    if (now.same) {
      row = now.a_row;
      spaces = (lines[row].match(/^\s*/))[0];
      space_n = spaces.length;
      reduce_n = 2 - spaces % 2;
      o(lines[row], spaces, space_n, reduce_n);
      if (space_n >= reduce_n) {
        lines[row] = lines[row].slice(reduce_n);
        obj = {
          lines: lines,
          a_row: row,
          a_col: now.a_col - reduce_n > 0 ? now.a_col - reduce_n : 0
        };
        tool.write_text(area, obj);
      }
    } else {
      sta_row = now.a_row;
      end_row = now.b_row;
      space_ns = lines.slice(sta_row, end_row + 1 || 9e9).map(function(line) {
        spaces = (line.match(/^\s*/))[0];
        return spaces.length;
      });
      o(space_ns);
      min_spaces = space_ns.reduce(function(a, b) {
        if (a < b) {
          return a;
        } else {
          return b;
        }
      });
      o(min_spaces);
      if (min_spaces > 0) {
        reduce_n = 2 - min_spaces % 2;
        for (index = _i = sta_row; sta_row <= end_row ? _i <= end_row : _i >= end_row; index = sta_row <= end_row ? ++_i : --_i) {
          lines[index] = lines[index].slice(reduce_n);
        }
        obj = {
          lines: lines,
          a_row: sta_row,
          a_col: now.a_col - reduce_n,
          b_row: end_row,
          b_col: now.b_col - reduce_n
        };
        tool.write_text(area, obj);
      }
    }
    return false;
  };
  key_ctrl_l = function(area) {
    var a_col, a_row, now, obj;
    now = tool.wrap_text(area);
    a_row = now.a_row;
    a_col = 0;
    if (now.lines[a_row - 1] != null) {
      a_row -= 1;
      a_col = void 0;
    }
    obj = {
      lines: now.lines,
      a_row: a_row,
      a_col: a_col,
      b_row: now.b_row
    };
    tool.write_text(area, obj);
    return false;
  };
  key_ctrl_k = function(area) {
    var col, lines, now, obj, row;
    now = tool.wrap_text(area);
    if (now.same) {
      lines = now.lines;
      row = now.a_row;
      col = now.a_col;
      lines[row] = lines[row].slice(0, col);
      obj = {
        lines: lines,
        a_row: row,
        a_col: col
      };
      tool.write_text(area, obj);
      return false;
    }
  };
  key_ctrl_u = function(area) {
    var col, lines, now, obj, row;
    now = tool.wrap_text(area);
    if (now.same) {
      lines = now.lines;
      row = now.a_row;
      col = now.a_col;
      lines[row] = lines[row].slice(col);
      obj = {
        lines: lines,
        a_row: row,
        a_col: 0
      };
      tool.write_text(area, obj);
      return false;
    }
  };
  key_esc = function(area) {
    return area.blur();
  };
  key_ctrl_shift_k = function(area) {
    var a_col, a_row, end_row, lines, now, obj, row, sta_row;
    now = tool.wrap_text(area);
    if (now.same) {
      row = now.a_row;
      lines = now.lines;
      lines = lines.slice(0, row).concat(lines.slice(row + 1));
      a_row = row;
      a_col = 0;
      if (row !== 0) {
        a_row = row - 1;
        a_col = void 0;
      }
      obj = {
        lines: lines,
        a_row: a_row,
        a_col: a_col
      };
      tool.write_text(area, obj);
    } else {
      sta_row = now.a_row;
      end_row = now.b_row;
      lines = now.lines;
      o('origin lines: ', lines);
      lines = lines.slice(0, sta_row).concat(lines.slice(end_row + 1));
      o('after; ', lines);
      a_row = sta_row > 0 ? sta_row - 1 : 0;
      obj = {
        lines: lines,
        a_row: a_row
      };
      o(obj);
      tool.write_text(area, obj);
    }
    return false;
  };
  key_ctrl_shift_d = function(area) {
    var duplicate, end_row, lines, now, obj, row, sta_row;
    now = tool.wrap_text(area);
    lines = now.lines;
    if (now.same) {
      row = now.a_row;
      lines = lines.slice(0, row + 1 || 9e9).concat(lines.slice(row));
      obj = {
        lines: lines,
        a_row: row + 1,
        a_col: now.a_col
      };
      tool.write_text(area, obj);
    } else {
      sta_row = now.a_row;
      end_row = now.b_row;
      lines = lines.slice(0, end_row + 1 || 9e9).concat(lines.slice(sta_row));
      duplicate = end_row - sta_row + 1;
      obj = {
        lines: lines,
        a_row: sta_row + duplicate,
        a_col: now.a_col,
        b_row: end_row + duplicate,
        b_col: now.b_col
      };
      tool.write_text(area, obj);
    }
    return false;
  };
  key_enter = function(area) {
    var col, lines, now, obj, row, space_n, spaces;
    now = tool.wrap_text(area);
    if (now.same) {
      row = now.a_row;
      col = now.a_col;
      lines = now.lines;
      lines = lines.slice(0, row + 1 || 9e9).concat(lines.slice(row));
      lines[row] = lines[row].slice(0, col);
      spaces = (lines[row].match(/^\s*/))[0];
      space_n = spaces.length;
      lines[row + 1] = spaces + lines[row + 1].slice(col);
      obj = {
        lines: lines,
        a_row: row + 1,
        a_col: space_n
      };
      tool.write_text(area, obj);
      return false;
    }
  };
  key_backspace = function(area) {
    var lines, now, obj, pair, row;
    now = tool.wrap_text(area);
    if (now.same) {
      row = now.a_row;
      lines = now.lines;
      if ((lines[row - 1] != null) && now.a_sta) {
        if (lines[row - 1].match(/^\s+$/)) {
          lines = lines.slice(0, row - 1).concat(lines.slice(row));
          obj = {
            lines: lines,
            a_row: row - 1,
            a_col: 0
          };
          tool.write_text(area, obj);
          return false;
        }
      }
      if (lines[row].length > 1 && (!now.a_end)) {
        pair = lines[row].slice(now.a_col - 1, now.a_col + 1 || 9e9);
        if (pair === '{}' || pair === '()' || pair === '[]' || pair === '""' || pair === "''" || pair === '``') {
          lines[row] = lines[row].slice(0, now.a_col) + lines[row].slice(now.a_col + 1);
          obj = {
            lines: lines,
            a_row: now.a_row,
            a_col: now.b_col
          };
          return tool.write_text(area, obj);
        }
      }
    }
  };
  key_ctrl_enter = function(area) {
    var lines, new_line, now, obj, row;
    now = tool.wrap_text(area);
    if (now.same) {
      row = now.a_row;
      lines = now.lines;
      new_line = (lines[row].match(/^\s*/))[0];
      lines = lines.slice(0, row + 1 || 9e9).concat([new_line]).concat(lines.slice(row + 1));
      obj = {
        lines: lines,
        a_row: row + 1
      };
      return tool.write_text(area, obj);
    }
  };
  key_ctrl_shift_enter = function(area) {
    var lines, new_line, now, obj, row;
    now = tool.wrap_text(area);
    if (now.same) {
      row = now.a_row;
      lines = now.lines;
      new_line = (lines[row].match(/^\s*/))[0];
      lines = lines.slice(0, row).concat([new_line]).concat(lines.slice(row));
      obj = {
        lines: lines,
        a_row: row
      };
      return tool.write_text(area, obj);
    }
  };
  key_ctrl_shift_up = function(area) {
    var end_row, index, line, lines, now, obj, row, sta_row, t_line, _i, _len, _ref, _ref1;
    now = tool.wrap_text(area);
    if (now.same) {
      row = now.a_row;
      if (row > 0) {
        lines = now.lines;
        _ref = [lines[row - 1], lines[row]], lines[row] = _ref[0], lines[row - 1] = _ref[1];
        obj = {
          lines: lines,
          a_row: row - 1,
          a_col: now.a_col
        };
        tool.write_text(area, obj);
      }
    } else {
      sta_row = now.a_row;
      end_row = now.b_row;
      if (sta_row > 0) {
        lines = now.lines;
        t_line = lines[sta_row - 1];
        _ref1 = lines.slice(sta_row, end_row + 1 || 9e9);
        for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
          line = _ref1[index];
          lines[sta_row + index - 1] = line;
        }
        lines[end_row] = t_line;
        obj = {
          lines: lines,
          a_row: sta_row - 1,
          a_col: now.a_col,
          b_row: end_row - 1,
          b_col: now.b_col
        };
        tool.write_text(area, obj);
      }
    }
    return false;
  };
  key_ctrl_shift_down = function(area) {
    var end_row, index, line, lines, now, obj, row, sta_row, t_line, _i, _len, _ref, _ref1;
    now = tool.wrap_text(area);
    lines = now.lines;
    if (now.same) {
      row = now.a_row;
      if (row < lines.length - 1) {
        _ref = [lines[row + 1], lines[row]], lines[row] = _ref[0], lines[row + 1] = _ref[1];
        obj = {
          lines: lines,
          a_row: row + 1,
          a_col: now.a_col
        };
        tool.write_text(area, obj);
      }
    } else {
      sta_row = now.a_row;
      end_row = now.b_row;
      if (end_row < lines.length - 1) {
        t_line = lines[end_row + 1];
        _ref1 = lines.slice(sta_row, end_row + 1 || 9e9);
        for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
          line = _ref1[index];
          lines[sta_row + index + 1] = line;
        }
        lines[sta_row] = t_line;
        obj = {
          lines: lines,
          a_row: sta_row + 1,
          a_col: now.a_col,
          b_row: end_row + 1,
          b_col: now.b_col
        };
        tool.write_text(area, obj);
      }
    }
    return false;
  };
  /*
    # go to the begining of whole page
    key_ctrl_home = (area) ->
      now = tool.wrap_text area
      if now.same
        obj =
          lines: now.lines
          a_row: 0
          a_col: 0
        tool.write_text area, obj
  
    # go to the end of whole page
    key_ctrl_end = (area) ->
      now = tool.wrap_text area
      if now.same
        lines = now.lines
        obj =
          lines: lines
          a_row: lines.length - 1
        tool.write_text area, obj
  */

  key_bracket = function(area, bracket) {
    var a_col, a_row, b_col, b_row, lines, now, obj;
    now = tool.wrap_text(area);
    lines = now.lines;
    a_row = now.a_row;
    a_col = now.a_col;
    b_row = now.b_row;
    b_col = now.b_col;
    lines[b_row] = lines[b_row].slice(0, b_col) + bracket[1] + lines[b_row].slice(b_col);
    lines[a_row] = lines[a_row].slice(0, a_col) + bracket[0] + lines[a_row].slice(a_col);
    obj = {
      lines: lines,
      a_row: a_row,
      a_col: a_col + 1,
      b_row: b_row,
      b_col: b_col + 1
    };
    tool.write_text(area, obj);
    return false;
  };
  key_bracket_close = function(area, closer) {
    var col, lines, now, obj, row, target;
    now = tool.wrap_text(area);
    if (now.same) {
      row = now.a_row;
      col = now.a_col;
      lines = now.lines;
      target = lines[row][col];
      if ((target != null) && target === closer) {
        obj = {
          lines: lines,
          a_row: row,
          a_col: col + 1
        };
        tool.write_text(area, obj);
        return false;
      }
    }
  };
  press = {
    enter: 13,
    tab: 9,
    shift: 16,
    alt: 18,
    backspace: 8,
    l: 76,
    k: 75,
    esc: 27,
    d: 68,
    u: 85,
    up: 38,
    down: 40,
    home: 36,
    end: 35,
    n9: 57,
    n0: 48,
    squBrac: 219,
    squBraC: 221,
    quote: 222,
    backquote: 192
  };
  map_keys = function(arr, area, key_equal) {
    if (key_equal(arr, [false, false, false, press.tab])) {
      return key_tab(area);
    }
    if (key_equal(arr, [false, false, false, press.enter])) {
      return key_enter(area);
    }
    if (key_equal(arr, [false, false, false, press.esc])) {
      return key_esc(area);
    }
    if (key_equal(arr, [false, false, false, press.backspace])) {
      return key_backspace(area);
    }
    if (key_equal(arr, [false, false, false, press.squBrac])) {
      return key_bracket(area, '[]');
    }
    if (key_equal(arr, [false, false, false, press.quote])) {
      return key_bracket(area, "''");
    }
    if (key_equal(arr, [false, false, false, press.backquote])) {
      return key_bracket(area, '``');
    }
    if (key_equal(arr, [false, false, false, press.squBraC])) {
      return key_bracket_close(area, ']');
    }
    if (key_equal(arr, [false, true, false, press.enter])) {
      return key_alt_enter(area);
    }
    if (key_equal(arr, [false, false, true, press.tab])) {
      return key_shift_tab(area);
    }
    if (key_equal(arr, [false, false, true, press.enter])) {
      return key_shift_enter(area);
    }
    if (key_equal(arr, [false, false, true, press.n9])) {
      return key_bracket(area, '()');
    }
    if (key_equal(arr, [false, false, true, press.n0])) {
      return key_bracket_close(area, ')');
    }
    if (key_equal(arr, [false, false, true, press.squBraC])) {
      return key_bracket_close(area, '}');
    }
    if (key_equal(arr, [false, false, true, press.squBrac])) {
      return key_bracket(area, '{}');
    }
    if (key_equal(arr, [false, false, true, press.quote])) {
      return key_bracket(area, '""');
    }
    if (key_equal(arr, [true, false, false, press.l])) {
      return key_ctrl_l(area);
    }
    if (key_equal(arr, [true, false, false, press.enter])) {
      return key_ctrl_enter(area);
    }
    if (key_equal(arr, [true, false, false, press.k])) {
      return key_ctrl_k(area);
    }
    if (key_equal(arr, [true, false, false, press.u])) {
      return key_ctrl_u(area);
    }
    if (key_equal(arr, [true, false, false, press.home])) {
      return key_ctrl_home(area);
    }
    if (key_equal(arr, [true, false, false, press.end])) {
      return key_ctrl_end(area);
    }
    if (key_equal(arr, [true, false, true, press.enter])) {
      return key_ctrl_shift_enter(area);
    }
    if (key_equal(arr, [true, false, true, press.k])) {
      return key_ctrl_shift_k(area);
    }
    if (key_equal(arr, [true, false, true, press.d])) {
      return key_ctrl_shift_d(area);
    }
    if (key_equal(arr, [true, false, true, press.up])) {
      return key_ctrl_shift_up(area);
    }
    if (key_equal(arr, [true, false, true, press.down])) {
      return key_ctrl_shift_down(area);
    }
  };
  return event_handler(target_id);
};
